/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.4.6. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module serial
    ( // Inputs
      input  clk // clock
    , input  reset // reset
    , input  enable // enable
    , input  can_send
    , input [7:0] data_in
    , input  in_stb

      // Outputs
    , output wire [7:0] data_out
    , output wire  out_stb
    );
  // Lib.hs:18:1-36
  wire [8:0] c$ds_app_arg;
  // Puzzle.hs:(12,1)-(13,67)
  reg [58:0] maybeToBoola_c$ds_app_arg = {2'd0,   {14'd0,   14'd0,   14'd0,   14'd0},   1'b0};
  wire [33:0] result_0;
  wire [92:0] result_1;
  reg [33:0] c$app_arg;
  wire [33:0] c$case_alt;
  wire [31:0] c$app_arg_0;
  wire [127:0] c$app_arg_1;
  // Puzzle.hs:40:1-11
  reg  \done' ;
  reg [55:0] c$app_arg_2;
  wire [55:0] c$case_alt_0;
  wire [55:0] result_2;
  wire signed [63:0] c$app_arg_3;
  // Puzzle.hs:40:1-11
  wire signed [63:0] wild3;
  // Puzzle.hs:40:1-11
  wire [55:0] numbers1;
  // Puzzle.hs:40:1-11
  wire signed [63:0] c$wild3_app_arg;
  reg [1:0] c$app_arg_4;
  // Puzzle.hs:40:1-11
  wire [1:0] action;
  wire [1:0] c$case_alt_1;
  // Puzzle.hs:40:1-11
  wire [1:0] digitIdx1;
  // Puzzle.hs:40:1-11
  wire  \c$done'_case_alt ;
  // Puzzle.hs:40:1-11
  reg  \c$done'_case_alt_0 ;
  reg [1:0] result_3;
  // Puzzle.hs:40:1-11
  wire [7:0] a1;
  // Puzzle.hs:(16,1)-(17,69)
  reg [97:0] maybeToBoola_c$ds_app_arg_0 = {32'd0,   16'd65535,   {16'd21845,   16'd21845,   16'd21845},   2'd0};
  wire [32:0] result_4;
  wire [130:0] result_5;
  wire [32:0] c$app_arg_5;
  wire [32:0] c$case_alt_2;
  // Puzzle.hs:93:1-11
  wire [31:0] \count' ;
  // Puzzle.hs:93:1-11
  wire [1:0] phase;
  wire [47:0] c$app_arg_6;
  wire [47:0] c$case_alt_3;
  // Puzzle.hs:93:1-11
  wire [31:0] h;
  // Puzzle.hs:93:1-11
  wire [31:0] count;
  // Puzzle.hs:93:1-11
  wire [15:0] \prevSum' ;
  // Puzzle.hs:93:1-11
  wire [47:0] window;
  // Puzzle.hs:93:1-11
  wire [15:0] prevSum;
  // Puzzle.hs:(20,1)-(21,68)
  reg [36:0] maybeToBoola_c$ds_app_arg_1 = {{1'b0,32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx},   4'd0};
  wire [8:0] result_6;
  wire [45:0] c$case_alt_4;
  wire [8:0] c$app_arg_7;
  wire [8:0] c$case_alt_5;
  wire [7:0] result_7;
  wire signed [63:0] c$app_arg_8;
  wire signed [63:0] c$app_arg_9;
  // Puzzle.hs:118:1-15
  wire [31:0] a;
  wire [3:0] c$app_arg_10;
  wire [4:0] z;
  wire [3:0] result_8;
  // Puzzle.hs:118:1-15
  wire [3:0] digitIdx1_0;
  wire [32:0] c$app_arg_11;
  // Puzzle.hs:118:1-15
  wire [31:0] n;
  // Puzzle.hs:118:1-15
  wire [32:0] number;
  // Lib.hs:(22,1)-(23,72)
  reg [265:0] maybeToBoola_c$ds_app_arg_2 = {{8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
  8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
  8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
  8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
  8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
  8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
  8'b00000001,   8'b00000001},   5'd0,   5'd0};
  wire [8:0] result_9;
  // Lib.hs:40:1-15
  wire signed [63:0] c$wild3_app_arg_0;
  wire [255:0] result_10;
  wire [255:0] c$app_arg_12;
  wire [4:0] c$app_arg_13;
  wire [4:0] c$app_arg_14;
  // Lib.hs:40:1-15
  wire signed [63:0] c$wild3_app_arg_1;
  wire [7:0] result_11;
  wire [8:0] c$app_arg_15;
  wire [274:0] result_12;
  // Lib.hs:40:1-15
  wire  canSend;
  // Lib.hs:40:1-15
  wire [7:0] a_0;
  // Lib.hs:40:1-15
  wire signed [63:0] wild3_0;
  // Lib.hs:40:1-15
  wire signed [63:0] wild3_1;
  // Lib.hs:40:1-15
  wire  doSend;
  // Lib.hs:40:1-15
  wire [4:0] readPointer1;
  // Lib.hs:40:1-15
  wire [4:0] writePointer1;
  // Lib.hs:40:1-15
  wire [255:0] memory1;
  // Lib.hs:18:1-36
  wire [7:0] a1_0;
  wire [9:0] eta;
  wire [55:0] c$vec;
  wire [7:0] c$bv;
  wire [3:0] result_selection_res;
  wire [7:0] c$bv_0;
  wire [32:0] c$case_alt_selection_4;
  wire [32:0] c$case_alt_selection_7;
  wire [63:0] c$case_alt_sel_alt_f_4;
  wire [31:0] c$i_34;
  wire [31:0] c$i_36;
  wire [8:0] result;

  assign eta = {can_send,   data_in,   in_stb};

  assign c$ds_app_arg = eta[0:0] ? {1'b1,eta[8:1]} : {1'b0,8'bxxxxxxxx};

  // register begin
  always @(posedge clk or  posedge  reset) begin : maybeToBoola_c$ds_app_arg_register
    if ( reset) begin
      maybeToBoola_c$ds_app_arg <= {2'd0,   {14'd0,   14'd0,   14'd0,   14'd0},   1'b0};
    end else if (enable) begin
      maybeToBoola_c$ds_app_arg <= result_1[92:34];
    end
  end
  // register end

  assign result_0 = result_1[33:0];

  assign result_1 = {{c$app_arg_4,   c$app_arg_2,
                      \done' },   c$app_arg};

  always @(*) begin
    case(action)
      2'b00 : c$app_arg = c$case_alt;
      default : c$app_arg = {1'b0,33'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx};
    endcase
  end

  assign c$case_alt = \done'  ? {1'b1,{1'b1,32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}} : {1'b1,{1'b0,c$app_arg_0}};

  wire [127:0] vec;
  wire [31:0] acc_2_0;
  wire [31:0] acc_1;
  wire [31:0] acc_2;
  wire [31:0] acc_3;
  wire [31:0] acc_4;
  wire [31:0] acc_1_0;
  wire [31:0] acc_1_1;
  assign c$app_arg_0 = acc_2_0;

  assign vec = c$app_arg_1;

  assign acc_1 = vec[127:96];

  assign acc_2 = vec[95:64];

  assign acc_3 = vec[63:32];

  assign acc_4 = vec[31:0];

  assign acc_1_0 = acc_1 + acc_2;



  assign acc_1_1 = acc_3 + acc_4;



  assign acc_2_0 = acc_1_0 + acc_1_1;





  // map begin
  genvar i;
  generate
  for (i=0; i < 4; i = i + 1) begin : map
    wire [13:0] map_in;
    assign map_in = numbers1[i*14+:14];
    wire [31:0] map_out;
    assign map_out = {{(32-14) {1'b0}},map_in};


    assign c$app_arg_1[i*32+:32] = map_out;
  end
  endgenerate
  // map end

  always @(*) begin
    case(digitIdx1)
      2'd0 : \done'  = \c$done'_case_alt ;
      default : \done'  = maybeToBoola_c$ds_app_arg[0:0];
    endcase
  end

  always @(*) begin
    case(action)
      2'b00 : c$app_arg_2 = {4 {14'd0}};
      default : c$app_arg_2 = c$case_alt_0;
    endcase
  end

  assign c$case_alt_0 = c$ds_app_arg[8:8] ? result_2 : numbers1;

  assign c$vec = {numbers1[55:42] * 14'd10,
                  numbers1[41:28] * 14'd10,
                  numbers1[27:14] * 14'd10,
                  numbers1[13:0] * 14'd10};

  // vector replace begin
  genvar i_0;
  generate
  for (i_0=0;i_0<4;i_0=i_0+1) begin : vector_replace
    assign result_2[(3-i_0)*14+:14] = (wild3) == i_0 ? ($unsigned(c$app_arg_3[0+:14])) : c$vec[(3-i_0)*14+:14];
  end
  endgenerate
  // vector replace end

  assign c$bv = (a1 & 8'b00001111);

  assign c$app_arg_3 = $unsigned({{(64-8) {1'b0}},c$bv});

  assign wild3 = $signed(c$wild3_app_arg);

  assign numbers1 = maybeToBoola_c$ds_app_arg[56:1];

  assign c$wild3_app_arg = $unsigned({{(64-2) {1'b0}},digitIdx1});

  always @(*) begin
    case(action)
      2'b01 : c$app_arg_4 = c$case_alt_1;
      2'b11 : c$app_arg_4 = digitIdx1;
      default : c$app_arg_4 = 2'd0;
    endcase
  end

  assign action = c$ds_app_arg[8:8] ? result_3 : 2'd3;

  assign c$case_alt_1 = (digitIdx1 < 2'd3) ? (digitIdx1 + 2'd1) : digitIdx1;

  assign digitIdx1 = maybeToBoola_c$ds_app_arg[58:57];

  assign \c$done'_case_alt  = c$ds_app_arg[8:8] ? \c$done'_case_alt_0  : maybeToBoola_c$ds_app_arg[0:0];

  always @(*) begin
    case(a1)
      8'b00001010 : \c$done'_case_alt_0  = 1'b1;
      default : \c$done'_case_alt_0  = maybeToBoola_c$ds_app_arg[0:0];
    endcase
  end

  assign c$bv_0 = (a1 >> (64'sd4));

  assign result_selection_res = c$bv_0[0+:4];

  always @(*) begin
    case(result_selection_res)
      4'b0011 : result_3 = 2'd1;
      4'b0000 : result_3 = 2'd0;
      default : result_3 = 2'd2;
    endcase
  end

  assign a1 = c$ds_app_arg[7:0];

  // register begin
  always @(posedge clk or  posedge  reset) begin : maybeToBoola_c$ds_app_arg_0_register
    if ( reset) begin
      maybeToBoola_c$ds_app_arg_0 <= {32'd0,   16'd65535,   {16'd21845,   16'd21845,   16'd21845},   2'd0};
    end else if (enable) begin
      maybeToBoola_c$ds_app_arg_0 <= result_5[130:33];
    end
  end
  // register end

  assign result_4 = result_5[32:0];

  assign result_5 = {{\count' ,   \prevSum' ,
                      c$app_arg_6,   phase},   c$app_arg_5};

  assign c$app_arg_5 = result_0[33:33] ? c$case_alt_2 : {1'b0,32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx};

  assign c$case_alt_selection_4 = result_0[32:0];

  assign c$case_alt_2 = c$case_alt_selection_4[32:32] ? {1'b1,\count' } : {1'b0,32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx};

  assign \count'  = (\prevSum'  > prevSum) ? (count + 32'd1) : count;

  assign phase = maybeToBoola_c$ds_app_arg_0[1:0];

  assign c$app_arg_6 = result_0[33:33] ? c$case_alt_3 : window;

  assign c$case_alt_selection_7 = result_0[32:0];

  assign c$case_alt_sel_alt_f_4 = ({h[0+:16],window});

  assign c$case_alt_3 = c$case_alt_selection_7[32:32] ? window : c$case_alt_sel_alt_f_4[63:16];

  assign h = result_0[31:0];

  assign count = maybeToBoola_c$ds_app_arg_0[97:66];

  wire [47:0] vec_0;
  wire [15:0] acc_2_0_1;
  wire [15:0] acc_0_3;
  wire [15:0] acc_0_4;
  wire [15:0] acc_1_0_0;
  wire [15:0] acc_0_5;
  assign \prevSum'  = acc_2_0_1;

  assign vec_0 = window;

  assign acc_0_3 = vec_0[47:32];

  assign acc_0_4 = vec_0[31:16];

  assign acc_0_5 = vec_0[15:0];

  assign acc_1_0_0 = acc_0_3 + acc_0_4;



  assign acc_2_0_1 = acc_1_0_0 + acc_0_5;





  assign window = maybeToBoola_c$ds_app_arg_0[49:2];

  assign prevSum = maybeToBoola_c$ds_app_arg_0[65:50];

  // register begin
  always @(posedge clk or  posedge  reset) begin : maybeToBoola_c$ds_app_arg_1_register
    if ( reset) begin
      maybeToBoola_c$ds_app_arg_1 <= {{1'b0,32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx},   4'd0};
    end else if (enable) begin
      maybeToBoola_c$ds_app_arg_1 <= c$case_alt_4[45:9];
    end
  end
  // register end

  assign result_6 = c$case_alt_4[8:0];

  assign c$case_alt_4 = {{c$app_arg_11,
                          c$app_arg_10},   c$app_arg_7};

  assign c$app_arg_7 = (digitIdx1_0 < 4'd8) ? c$case_alt_5 : {1'b0,8'bxxxxxxxx};

  assign c$case_alt_5 = number[32:32] ? {1'b1,result_7} : {1'b0,8'bxxxxxxxx};

  assign result_7 = (a <= 32'd9) ? ($unsigned(c$app_arg_8[0+:8])) : ($unsigned(c$app_arg_9[0+:8]));

  assign c$i_34 = (32'd48 | a);

  assign c$app_arg_8 = $unsigned({{(64-32) {1'b0}},c$i_34});

  assign c$i_36 = (a + 32'd87);

  assign c$app_arg_9 = $unsigned({{(64-32) {1'b0}},c$i_36});

  assign a = n >> (64'sd28);

  assign c$app_arg_10 = number[32:32] ? result_8 : 4'd0;

  assign z = digitIdx1_0 + 4'd1;

  assign result_8 = (z > 5'd8) ? 4'd8 : (z[0+:4]);

  assign digitIdx1_0 = maybeToBoola_c$ds_app_arg_1[3:0];

  assign c$app_arg_11 = number[32:32] ? {1'b1,n << (64'sd4)} : result_4;

  assign n = number[31:0];

  assign number = maybeToBoola_c$ds_app_arg_1[36:4];

  // register begin
  always @(posedge clk or  posedge  reset) begin : maybeToBoola_c$ds_app_arg_2_register
    if ( reset) begin
      maybeToBoola_c$ds_app_arg_2 <= {{8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
    8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
    8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
    8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
    8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
    8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,   8'b00000001,
    8'b00000001,   8'b00000001},   5'd0,   5'd0};
    end else if (enable) begin
      maybeToBoola_c$ds_app_arg_2 <= result_12[274:9];
    end
  end
  // register end

  assign result_9 = result_12[8:0];

  assign c$wild3_app_arg_0 = $unsigned({{(64-5) {1'b0}},writePointer1});

  // vector replace begin
  genvar i_1;
  generate
  for (i_1=0;i_1<32;i_1=i_1+1) begin : vector_replace_0
    assign result_10[(31-i_1)*8+:8] = (wild3_0) == i_1 ? a_0 : memory1[(31-i_1)*8+:8];
  end
  endgenerate
  // vector replace end

  assign c$app_arg_12 = result_6[8:8] ? result_10 : memory1;

  assign c$app_arg_13 = result_6[8:8] ? (writePointer1 + 5'd1) : writePointer1;

  assign c$app_arg_14 = doSend ? (readPointer1 + 5'd1) : readPointer1;

  assign c$wild3_app_arg_1 = $unsigned({{(64-5) {1'b0}},readPointer1});

  // index begin
  wire [7:0] vecArray [0:32-1];
  genvar i_2;
  generate
  for (i_2=0; i_2 < 32; i_2=i_2+1) begin : mk_array
    assign vecArray[(32-1)-i_2] = memory1[i_2*8+:8];
  end
  endgenerate
  assign result_11 = vecArray[(wild3_1)];
  // index end

  assign c$app_arg_15 = doSend ? {1'b1,result_11} : {1'b0,8'bxxxxxxxx};

  assign result_12 = {{c$app_arg_12,
                       c$app_arg_13,   c$app_arg_14},   c$app_arg_15};

  assign canSend = eta[9:9];

  assign a_0 = result_6[7:0];

  assign wild3_0 = $signed(c$wild3_app_arg_0);

  assign wild3_1 = $signed(c$wild3_app_arg_1);

  assign doSend = canSend ? (writePointer1 > readPointer1) : 1'b0;

  assign readPointer1 = maybeToBoola_c$ds_app_arg_2[4:0];

  assign writePointer1 = maybeToBoola_c$ds_app_arg_2[9:5];

  assign memory1 = maybeToBoola_c$ds_app_arg_2[265:10];

  assign result = result_9[8:8] ? {a1_0,
                                   1'b1} : {{8 {1'bx}},   1'b0};

  assign a1_0 = result_9[7:0];

  assign data_out = result[8:1];

  assign out_stb = result[0:0];


endmodule

